<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Property Test 5 - Report Creation Persistence</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .test-results {
            background: white;
            padding: 20px;
            border-radius: 5px;
            margin: 10px 0;
        }
        .test-pass {
            color: green;
            font-weight: bold;
        }
        .test-fail {
            color: red;
            font-weight: bold;
        }
        .test-running {
            color: orange;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <h1>Property Test 5: Report Creation Persistence</h1>
    <p><strong>Feature:</strong> simple-login-auth, Property 5: Report creation persistence</p>
    <p><strong>Validates:</strong> Requirements 5.4, 5.5</p>
    <div id="test-results"></div>
    
    <script src="scripts/utils.js"></script>
    <script src="scripts/data-loader.js"></script>
    <script>
        // Simple property-based testing framework
        class SimplePropertyTest {
            constructor() {
                this.results = [];
            }

            // Generate random string
            randomString(minLength = 1, maxLength = 20) {
                const chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 ';
                const length = Math.floor(Math.random() * (maxLength - minLength + 1)) + minLength;
                let result = '';
                for (let i = 0; i < length; i++) {
                    result += chars.charAt(Math.floor(Math.random() * chars.length));
                }
                return result.trim();
            }

            // Generate random date in the past
            randomPastDate() {
                const start = new Date('2020-01-01');
                const end = new Date();
                const randomTime = start.getTime() + Math.random() * (end.getTime() - start.getTime());
                return new Date(randomTime);
            }

            // Run property test
            async runProperty(name, propertyFn, numRuns = 100) {
                const resultsDiv = document.getElementById('test-results');
                const testDiv = document.createElement('div');
                testDiv.className = 'test-results';
                testDiv.innerHTML = `<div class="test-running">Running: ${name}...</div>`;
                resultsDiv.appendChild(testDiv);

                try {
                    for (let i = 0; i < numRuns; i++) {
                        await propertyFn();
                    }
                    testDiv.innerHTML = `<div class="test-pass">✓ PASS: ${name} (${numRuns} runs)</div>`;
                    this.results.push({ name, status: 'PASS' });
                } catch (error) {
                    testDiv.innerHTML = `<div class="test-fail">✗ FAIL: ${name}<br>Error: ${error.message}</div>`;
                    this.results.push({ name, status: 'FAIL', error: error.message });
                }
            }
        }

        // Mock DataLoader for testing
        class MockDataLoader {
            constructor() {
                this.mockReportsData = {
                    "report_001": {
                        "id": "report_001",
                        "title": "Investigação Paranormal - Casa Abandonada",
                        "description": "Relatório detalhado da investigação...",
                        "missionDate": "2024-12-01",
                        "status": "completed",
                        "authorId": "user_001",
                        "authorName": "Bella Evans",
                        "createdAt": "2024-12-01T18:30:00Z",
                        "updatedAt": "2024-12-01T18:30:00Z",
                        "sharedWith": ["user_002"],
                        "isPublic": false
                    }
                };
            }

            async loadReports() {
                return this.mockReportsData;
            }
        }

        // Mock AuthService for testing
        class MockAuthService {
            constructor() {
                this.currentUser = {
                    id: "user_001",
                    username: "bella_evans",
                    name: "Bella Evans",
                    role: "agent",
                    team: "team_alpha"
                };
            }

            getCurrentUser() {
                return this.currentUser;
            }

            checkSession() {
                return true;
            }
        }

        // Mock ReportsService with MockDataLoader
        class MockReportsService {
            constructor() {
                this.dataLoader = new MockDataLoader();
                this.localStorageKey = 'ordem_paranormal_reports_test';
                this.mockLocalStorage = {};
            }

            // Mock localStorage methods for testing
            getLocalReports() {
                try {
                    const stored = this.mockLocalStorage[this.localStorageKey];
                    return stored ? JSON.parse(stored) : {};
                } catch (error) {
                    console.error('Error loading local reports:', error);
                    return {};
                }
            }

            saveLocalReports(reports) {
                try {
                    this.mockLocalStorage[this.localStorageKey] = JSON.stringify(reports);
                    return true;
                } catch (error) {
                    console.error('Error saving local reports:', error);
                    return false;
                }
            }

            generateReportId() {
                const timestamp = Date.now();
                const random = Math.random().toString(36).substr(2, 9);
                return `report_${timestamp}_${random}`;
            }

            async getAllReports() {
                try {
                    const staticReports = await this.dataLoader.loadReports();
                    const localReports = this.getLocalReports();
                    return { ...staticReports, ...localReports };
                } catch (error) {
                    console.error('Error loading all reports:', error);
                    return this.getLocalReports();
                }
            }

            async loadReports(userId) {
                try {
                    const allReports = await this.getAllReports();
                    return Object.values(allReports).filter(report => report.authorId === userId);
                } catch (error) {
                    console.error('Error loading reports:', error);
                    return [];
                }
            }

            async createReport(reportData) {
                try {
                    // Validate required fields
                    if (!reportData.title || !reportData.description || !reportData.missionDate || !reportData.status) {
                        return {
                            success: false,
                            message: 'Todos os campos obrigatórios devem ser preenchidos'
                        };
                    }

                    // Get current user from mock auth service
                    const authService = new MockAuthService();
                    const currentUser = authService.getCurrentUser();
                    
                    if (!currentUser) {
                        return {
                            success: false,
                            message: 'Usuário não autenticado'
                        };
                    }

                    // Generate unique ID and timestamps
                    const reportId = this.generateReportId();
                    const now = new Date().toISOString();

                    // Create report object
                    const newReport = {
                        id: reportId,
                        title: reportData.title.trim(),
                        description: reportData.description.trim(),
                        missionDate: reportData.missionDate,
                        status: reportData.status,
                        authorId: currentUser.id,
                        authorName: currentUser.name || currentUser.username,
                        createdAt: now,
                        updatedAt: now,
                        sharedWith: [],
                        isPublic: false
                    };

                    // Load existing local reports
                    const localReports = this.getLocalReports();
                    
                    // Add new report
                    localReports[reportId] = newReport;
                    
                    // Save to localStorage
                    if (!this.saveLocalReports(localReports)) {
                        return {
                            success: false,
                            message: 'Erro ao salvar relatório'
                        };
                    }

                    return {
                        success: true,
                        message: 'Relatório criado com sucesso!',
                        report: newReport
                    };

                } catch (error) {
                    console.error('Error creating report:', error);
                    return {
                        success: false,
                        message: 'Erro interno do sistema'
                    };
                }
            }
        }

        // Run the property tests
        async function runTests() {
            const tester = new SimplePropertyTest();
            const reportsService = new MockReportsService();

            /**
             * Property 5: Report creation persistence
             * For any valid report data submitted by an authenticated user, the system should save the report with unique ID and timestamp
             */

            // Test 1: Valid report data should be persisted
            await tester.runProperty(
                'Property 5a: Valid report data persistence',
                async () => {
                    const validStatuses = ['completed', 'partial', 'failed'];
                    
                    // Generate random valid report data
                    const title = tester.randomString(3, 100);
                    const description = tester.randomString(10, 500);
                    const missionDate = tester.randomPastDate().toISOString().split('T')[0];
                    const status = validStatuses[Math.floor(Math.random() * validStatuses.length)];
                    
                    const reportData = {
                        title: title,
                        description: description,
                        missionDate: missionDate,
                        status: status
                    };

                    // Create the report
                    const result = await reportsService.createReport(reportData);
                    
                    // For any valid report data, creation should succeed
                    if (!result.success) {
                        throw new Error(`Report creation should succeed for valid data: ${result.message}`);
                    }
                    
                    if (!result.report) {
                        throw new Error('Created report should be returned');
                    }
                    
                    // Verify report has unique ID and timestamp
                    if (!result.report.id || !result.report.id.match(/^report_\d+_[a-z0-9]+$/)) {
                        throw new Error('Report should have unique ID with correct format');
                    }
                    
                    if (!result.report.createdAt || !result.report.updatedAt) {
                        throw new Error('Report should have timestamps');
                    }
                    
                    // Verify report data is preserved
                    if (result.report.title !== reportData.title.trim()) {
                        throw new Error('Report title should be preserved');
                    }
                    
                    if (result.report.description !== reportData.description.trim()) {
                        throw new Error('Report description should be preserved');
                    }
                    
                    if (result.report.missionDate !== reportData.missionDate) {
                        throw new Error('Report mission date should be preserved');
                    }
                    
                    if (result.report.status !== reportData.status) {
                        throw new Error('Report status should be preserved');
                    }
                    
                    // Verify author information is set
                    if (result.report.authorId !== 'user_001') {
                        throw new Error('Report should have correct author ID');
                    }
                    
                    if (result.report.authorName !== 'Bella Evans') {
                        throw new Error('Report should have correct author name');
                    }
                    
                    // Verify report is persisted - should be retrievable
                    const userReports = await reportsService.loadReports('user_001');
                    const savedReport = userReports.find(r => r.id === result.report.id);
                    
                    if (!savedReport) {
                        throw new Error('Created report should be retrievable');
                    }
                    
                    if (savedReport.title !== reportData.title.trim()) {
                        throw new Error('Persisted report should maintain title');
                    }
                }
            );

            // Test 2: Unique IDs are generated
            await tester.runProperty(
                'Property 5b: Unique ID generation',
                async () => {
                    const reportData = {
                        title: 'Test Report',
                        description: 'This is a test report description with enough characters.',
                        missionDate: '2024-12-01',
                        status: 'completed'
                    };

                    const numReports = Math.floor(Math.random() * 5) + 2; // 2-6 reports
                    const createdReports = [];
                    
                    // Create multiple reports
                    for (let i = 0; i < numReports; i++) {
                        const result = await reportsService.createReport({
                            ...reportData,
                            title: `${reportData.title} ${i}`
                        });
                        
                        if (!result.success) {
                            throw new Error(`Report creation should succeed: ${result.message}`);
                        }
                        
                        createdReports.push(result.report);
                    }
                    
                    // Verify all IDs are unique
                    const ids = createdReports.map(r => r.id);
                    const uniqueIds = new Set(ids);
                    
                    if (uniqueIds.size !== ids.length) {
                        throw new Error('All report IDs should be unique');
                    }
                    
                    // Verify all reports are persisted
                    const userReports = await reportsService.loadReports('user_001');
                    
                    if (userReports.length < numReports) {
                        throw new Error('All created reports should be persisted');
                    }
                }
            );

            // Test 3: Invalid data is rejected
            await tester.runProperty(
                'Property 5c: Invalid data rejection',
                async () => {
                    const invalidReportCases = [
                        { title: '', description: 'Valid description', missionDate: '2024-12-01', status: 'completed' },
                        { title: 'Valid title', description: '', missionDate: '2024-12-01', status: 'completed' },
                        { title: 'Valid title', description: 'Valid description', missionDate: '', status: 'completed' },
                        { title: 'Valid title', description: 'Valid description', missionDate: '2024-12-01', status: '' },
                    ];

                    const invalidData = invalidReportCases[Math.floor(Math.random() * invalidReportCases.length)];
                    const result = await reportsService.createReport(invalidData);
                    
                    // For any invalid report data, creation should fail
                    if (result.success) {
                        throw new Error('Report creation should fail for invalid data');
                    }
                    
                    if (result.message !== 'Todos os campos obrigatórios devem ser preenchidos') {
                        throw new Error('Should return correct error message for invalid data');
                    }
                    
                    if (result.report) {
                        throw new Error('Should not return report object for failed creation');
                    }
                }
            );

            // Test 4: Timestamps are valid ISO strings
            await tester.runProperty(
                'Property 5d: Valid timestamp format',
                async () => {
                    const reportData = {
                        title: 'Timestamp Test Report',
                        description: 'Testing that timestamps are properly formatted ISO strings.',
                        missionDate: '2024-12-01',
                        status: 'completed'
                    };

                    const result = await reportsService.createReport(reportData);
                    
                    if (!result.success) {
                        throw new Error(`Report creation should succeed: ${result.message}`);
                    }
                    
                    // Verify timestamps are valid ISO strings
                    const isoRegex = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{3}Z$/;
                    
                    if (!isoRegex.test(result.report.createdAt)) {
                        throw new Error('createdAt should be valid ISO string');
                    }
                    
                    if (!isoRegex.test(result.report.updatedAt)) {
                        throw new Error('updatedAt should be valid ISO string');
                    }
                    
                    // Verify timestamps can be parsed as valid dates
                    const createdDate = new Date(result.report.createdAt);
                    const updatedDate = new Date(result.report.updatedAt);
                    
                    if (isNaN(createdDate.getTime())) {
                        throw new Error('createdAt should be parseable as date');
                    }
                    
                    if (isNaN(updatedDate.getTime())) {
                        throw new Error('updatedAt should be parseable as date');
                    }
                    
                    // For new reports, created and updated timestamps should be the same
                    if (result.report.createdAt !== result.report.updatedAt) {
                        throw new Error('For new reports, createdAt and updatedAt should be the same');
                    }
                }
            );

            // Display summary
            const resultsDiv = document.getElementById('test-results');
            const summaryDiv = document.createElement('div');
            summaryDiv.className = 'test-results';
            
            const passed = tester.results.filter(r => r.status === 'PASS').length;
            const failed = tester.results.filter(r => r.status === 'FAIL').length;
            
            summaryDiv.innerHTML = `
                <h3>Test Summary</h3>
                <p><strong>Total Tests:</strong> ${tester.results.length}</p>
                <p><strong>Passed:</strong> <span class="test-pass">${passed}</span></p>
                <p><strong>Failed:</strong> <span class="test-fail">${failed}</span></p>
                ${failed === 0 ? '<p><strong>✓ All property tests passed!</strong></p>' : '<p><strong>✗ Some tests failed</strong></p>'}
            `;
            
            resultsDiv.appendChild(summaryDiv);
        }

        // Start tests when page loads
        window.addEventListener('load', runTests);
    </script>
</body>
</html>