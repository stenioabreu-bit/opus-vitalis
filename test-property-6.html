<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Property 6 Test - Report Ownership</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .test-results {
            background: white;
            padding: 20px;
            border-radius: 5px;
            margin: 10px 0;
        }
        .test-pass {
            color: green;
            font-weight: bold;
        }
        .test-fail {
            color: red;
            font-weight: bold;
        }
        .test-running {
            color: orange;
            font-weight: bold;
        }
        .test-details {
            margin-top: 10px;
            padding: 10px;
            background-color: #f9f9f9;
            border-left: 4px solid #ccc;
        }
    </style>
</head>
<body>
    <h1>Property 6: Report Ownership Test</h1>
    <p><strong>Feature:</strong> simple-login-auth, Property 6: Report ownership</p>
    <p><strong>Validates:</strong> Requirements 6.3</p>
    <div id="test-results"></div>
    
    <script src="scripts/utils.js"></script>
    <script src="scripts/data-loader.js"></script>
    <script>
        // Simple property-based testing framework
        class SimplePropertyTest {
            constructor() {
                this.results = [];
            }

            // Generate random string
            randomString(minLength = 1, maxLength = 20) {
                const chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_';
                const length = Math.floor(Math.random() * (maxLength - minLength + 1)) + minLength;
                let result = '';
                for (let i = 0; i < length; i++) {
                    result += chars.charAt(Math.floor(Math.random() * chars.length));
                }
                return result;
            }

            // Generate random date
            randomDate() {
                const start = new Date('2020-01-01');
                const end = new Date();
                return new Date(start.getTime() + Math.random() * (end.getTime() - start.getTime()));
            }

            // Generate random status
            randomStatus() {
                const statuses = ['completed', 'partial', 'failed'];
                return statuses[Math.floor(Math.random() * statuses.length)];
            }

            // Run property test
            async runProperty(name, propertyFn, numRuns = 100) {
                const resultsDiv = document.getElementById('test-results');
                const testDiv = document.createElement('div');
                testDiv.className = 'test-results';
                testDiv.innerHTML = `<div class="test-running">Running: ${name}...</div>`;
                resultsDiv.appendChild(testDiv);

                let passCount = 0;
                let failCount = 0;
                let errors = [];

                try {
                    for (let i = 0; i < numRuns; i++) {
                        try {
                            await propertyFn();
                            passCount++;
                        } catch (error) {
                            failCount++;
                            if (errors.length < 5) { // Only store first 5 errors
                                errors.push(`Run ${i + 1}: ${error.message}`);
                            }
                        }
                    }
                    
                    if (failCount === 0) {
                        testDiv.innerHTML = `<div class="test-pass">✓ PASS: ${name} (${passCount}/${numRuns} runs passed)</div>`;
                        this.results.push({ name, status: 'PASS' });
                    } else {
                        testDiv.innerHTML = `
                            <div class="test-fail">✗ FAIL: ${name} (${passCount}/${numRuns} runs passed)</div>
                            <div class="test-details">
                                <strong>Sample errors:</strong><br>
                                ${errors.join('<br>')}
                            </div>
                        `;
                        this.results.push({ name, status: 'FAIL', errors });
                    }
                } catch (error) {
                    testDiv.innerHTML = `<div class="test-fail">✗ FAIL: ${name}<br>Setup Error: ${error.message}</div>`;
                    this.results.push({ name, status: 'FAIL', error: error.message });
                }
            }
        }

        // Mock ReportsService for testing
        class MockReportsService {
            constructor() {
                this.mockLocalStorage = {};
                this.localStorageKey = 'ordem_paranormal_reports';
                this.currentUser = {
                    id: "user_001",
                    username: "bella_evans",
                    name: "Bella Evans",
                    role: "agent",
                    team: "team_alpha"
                };
            }

            // Mock localStorage methods
            getLocalReports() {
                try {
                    const stored = this.mockLocalStorage[this.localStorageKey];
                    return stored ? JSON.parse(stored) : {};
                } catch (error) {
                    return {};
                }
            }

            saveLocalReports(reports) {
                try {
                    this.mockLocalStorage[this.localStorageKey] = JSON.stringify(reports);
                    return true;
                } catch (error) {
                    return false;
                }
            }

            generateReportId() {
                const timestamp = Date.now();
                const random = Math.random().toString(36).substring(2, 11);
                return `report_${timestamp}_${random}`;
            }

            async getAllReports() {
                return this.getLocalReports();
            }

            async createReport(reportData) {
                try {
                    // Validate required fields
                    if (!reportData.title || !reportData.description || !reportData.missionDate || !reportData.status) {
                        return {
                            success: false,
                            message: 'Todos os campos obrigatórios devem ser preenchidos'
                        };
                    }

                    // Generate unique ID and timestamps
                    const reportId = this.generateReportId();
                    const now = new Date().toISOString();

                    // Create report object
                    const newReport = {
                        id: reportId,
                        title: reportData.title.trim(),
                        description: reportData.description.trim(),
                        missionDate: reportData.missionDate,
                        status: reportData.status,
                        authorId: this.currentUser.id,
                        authorName: this.currentUser.name,
                        createdAt: now,
                        updatedAt: now,
                        sharedWith: [],
                        isPublic: false
                    };

                    // Load existing local reports
                    const localReports = this.getLocalReports();
                    
                    // Add new report
                    localReports[reportId] = newReport;
                    
                    // Save to localStorage
                    if (!this.saveLocalReports(localReports)) {
                        return {
                            success: false,
                            message: 'Erro ao salvar relatório'
                        };
                    }

                    return {
                        success: true,
                        message: 'Relatório criado com sucesso!',
                        report: newReport
                    };

                } catch (error) {
                    return {
                        success: false,
                        message: 'Erro interno do sistema'
                    };
                }
            }

            async getReport(reportId) {
                try {
                    const allReports = await this.getAllReports();
                    return allReports[reportId] || null;
                } catch (error) {
                    return null;
                }
            }

            async updateReport(reportId, reportData, userId) {
                try {
                    const allReports = await this.getAllReports();
                    const existingReport = allReports[reportId];
                    
                    if (!existingReport) {
                        return {
                            success: false,
                            message: 'Relatório não encontrado'
                        };
                    }
                    
                    // Check if user owns the report
                    if (existingReport.authorId !== userId) {
                        return {
                            success: false,
                            message: 'Você não tem permissão para editar este relatório'
                        };
                    }
                    
                    // Validate required fields
                    if (!reportData.title || !reportData.description || !reportData.missionDate || !reportData.status) {
                        return {
                            success: false,
                            message: 'Todos os campos obrigatórios devem ser preenchidos'
                        };
                    }
                    
                    // Update report data
                    const updatedReport = {
                        ...existingReport,
                        title: reportData.title.trim(),
                        description: reportData.description.trim(),
                        missionDate: reportData.missionDate,
                        status: reportData.status,
                        updatedAt: new Date().toISOString()
                    };
                    
                    // Save to localStorage
                    const localReports = this.getLocalReports();
                    localReports[reportId] = updatedReport;
                    
                    if (!this.saveLocalReports(localReports)) {
                        return {
                            success: false,
                            message: 'Erro ao salvar alterações'
                        };
                    }
                    
                    return {
                        success: true,
                        message: 'Relatório atualizado com sucesso!',
                        report: updatedReport
                    };
                    
                } catch (error) {
                    return {
                        success: false,
                        message: 'Erro interno do sistema'
                    };
                }
            }

            async deleteReport(reportId, userId) {
                try {
                    const allReports = await this.getAllReports();
                    const existingReport = allReports[reportId];
                    
                    if (!existingReport) {
                        return {
                            success: false,
                            message: 'Relatório não encontrado'
                        };
                    }
                    
                    // Check if user owns the report
                    if (existingReport.authorId !== userId) {
                        return {
                            success: false,
                            message: 'Você não tem permissão para excluir este relatório'
                        };
                    }
                    
                    // Remove from localStorage
                    const localReports = this.getLocalReports();
                    delete localReports[reportId];
                    
                    if (!this.saveLocalReports(localReports)) {
                        return {
                            success: false,
                            message: 'Erro ao excluir relatório'
                        };
                    }
                    
                    return {
                        success: true,
                        message: 'Relatório excluído com sucesso!'
                    };
                    
                } catch (error) {
                    return {
                        success: false,
                        message: 'Erro interno do sistema'
                    };
                }
            }
        }

        // Run the property tests
        async function runTests() {
            const tester = new SimplePropertyTest();
            const reportsService = new MockReportsService();

            /**
             * Property 6: Report ownership
             * For any created report, only the original author should have edit and delete permissions
             */

            // Test 1: Only author can edit reports
            await tester.runProperty(
                'Property 6a: Only author can edit reports',
                async () => {
                    // Generate random report data
                    const title = tester.randomString(5, 50);
                    const description = tester.randomString(20, 200);
                    const missionDate = tester.randomDate().toISOString().split('T')[0];
                    const status = tester.randomStatus();
                    const differentUserId = tester.randomString(5, 20);

                    const reportData = {
                        title: title,
                        description: description,
                        missionDate: missionDate,
                        status: status
                    };

                    // Create the report (as user_001)
                    const createResult = await reportsService.createReport(reportData);
                    if (!createResult.success) {
                        throw new Error(`Failed to create report: ${createResult.message}`);
                    }
                    
                    const reportId = createResult.report.id;
                    const authorId = createResult.report.authorId;
                    
                    // Ensure different user ID is actually different
                    const nonAuthorId = differentUserId === authorId ? `${differentUserId}_different` : differentUserId;
                    
                    // Try to edit as the author (should succeed)
                    const authorEditResult = await reportsService.updateReport(
                        reportId,
                        {
                            title: 'Updated by Author',
                            description: 'Updated description by author',
                            missionDate: reportData.missionDate,
                            status: reportData.status
                        },
                        authorId
                    );
                    
                    if (!authorEditResult.success) {
                        throw new Error(`Author should be able to edit their own report: ${authorEditResult.message}`);
                    }
                    
                    // Try to edit as a different user (should fail)
                    const nonAuthorEditResult = await reportsService.updateReport(
                        reportId,
                        {
                            title: 'Updated by Non-Author',
                            description: 'Updated description by non-author',
                            missionDate: reportData.missionDate,
                            status: reportData.status
                        },
                        nonAuthorId
                    );
                    
                    if (nonAuthorEditResult.success) {
                        throw new Error(`Non-author should not be able to edit report`);
                    }
                    
                    if (nonAuthorEditResult.message !== 'Você não tem permissão para editar este relatório') {
                        throw new Error(`Expected permission error message, got: ${nonAuthorEditResult.message}`);
                    }
                }
            );

            // Test 2: Only author can delete reports
            await tester.runProperty(
                'Property 6b: Only author can delete reports',
                async () => {
                    // Generate random report data
                    const title = tester.randomString(5, 50);
                    const description = tester.randomString(20, 200);
                    const missionDate = tester.randomDate().toISOString().split('T')[0];
                    const status = tester.randomStatus();
                    const differentUserId = tester.randomString(5, 20);

                    const reportData = {
                        title: title,
                        description: description,
                        missionDate: missionDate,
                        status: status
                    };

                    // Create the report (as user_001)
                    const createResult = await reportsService.createReport(reportData);
                    if (!createResult.success) {
                        throw new Error(`Failed to create report: ${createResult.message}`);
                    }
                    
                    const reportId = createResult.report.id;
                    const authorId = createResult.report.authorId;
                    
                    // Ensure different user ID is actually different
                    const nonAuthorId = differentUserId === authorId ? `${differentUserId}_different` : differentUserId;
                    
                    // Try to delete as a different user (should fail)
                    const nonAuthorDeleteResult = await reportsService.deleteReport(reportId, nonAuthorId);
                    
                    if (nonAuthorDeleteResult.success) {
                        throw new Error(`Non-author should not be able to delete report`);
                    }
                    
                    if (nonAuthorDeleteResult.message !== 'Você não tem permissão para excluir este relatório') {
                        throw new Error(`Expected permission error message, got: ${nonAuthorDeleteResult.message}`);
                    }
                    
                    // Verify report still exists
                    const reportStillExists = await reportsService.getReport(reportId);
                    if (!reportStillExists) {
                        throw new Error(`Report should still exist after failed delete attempt`);
                    }
                    
                    // Try to delete as the author (should succeed)
                    const authorDeleteResult = await reportsService.deleteReport(reportId, authorId);
                    
                    if (!authorDeleteResult.success) {
                        throw new Error(`Author should be able to delete their own report: ${authorDeleteResult.message}`);
                    }
                    
                    if (authorDeleteResult.message !== 'Relatório excluído com sucesso!') {
                        throw new Error(`Expected success message, got: ${authorDeleteResult.message}`);
                    }
                }
            );

            // Test 3: Non-existent report handling
            await tester.runProperty(
                'Property 6c: Non-existent report handling',
                async () => {
                    const fakeReportId = tester.randomString(10, 30);
                    const userId = tester.randomString(5, 20);
                    
                    // Try to edit non-existent report
                    const editResult = await reportsService.updateReport(
                        fakeReportId,
                        {
                            title: 'Updated Title',
                            description: 'Updated description',
                            missionDate: '2024-12-01',
                            status: 'completed'
                        },
                        userId
                    );
                    
                    if (editResult.success) {
                        throw new Error(`Edit should fail for non-existent report`);
                    }
                    
                    if (editResult.message !== 'Relatório não encontrado') {
                        throw new Error(`Expected 'not found' message, got: ${editResult.message}`);
                    }
                    
                    // Try to delete non-existent report
                    const deleteResult = await reportsService.deleteReport(fakeReportId, userId);
                    
                    if (deleteResult.success) {
                        throw new Error(`Delete should fail for non-existent report`);
                    }
                    
                    if (deleteResult.message !== 'Relatório não encontrado') {
                        throw new Error(`Expected 'not found' message, got: ${deleteResult.message}`);
                    }
                }
            );

            // Display summary
            const resultsDiv = document.getElementById('test-results');
            const summaryDiv = document.createElement('div');
            summaryDiv.className = 'test-results';
            
            const passed = tester.results.filter(r => r.status === 'PASS').length;
            const failed = tester.results.filter(r => r.status === 'FAIL').length;
            
            summaryDiv.innerHTML = `
                <h3>Test Summary</h3>
                <p><strong>Total Tests:</strong> ${tester.results.length}</p>
                <p><strong>Passed:</strong> <span class="test-pass">${passed}</span></p>
                <p><strong>Failed:</strong> <span class="test-fail">${failed}</span></p>
                ${failed === 0 ? '<p><strong>✓ Property 6: Report ownership - ALL TESTS PASSED</strong></p>' : ''}
            `;
            
            resultsDiv.appendChild(summaryDiv);
        }

        // Start tests when page loads
        window.addEventListener('load', runTests);
    </script>
</body>
</html>